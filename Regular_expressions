# Regular_Expressions  
<br>

### Начало и конец строки
* ```^``` (крышка, кумфлекс) - начало проверяемой строки;
* ```$``` (знак доллара) - конец проверяемой строки.  
*Специфика символов ^ и $ заключается в том, что они совпадают с опредделенной позицией в строке, а не с символами текста.*  
<br>

```Пример поиска в начале строки```  
Интерпретировать запись регулярного выражения следует как - ```'^Br'``` совпадает если мы находимся в начале строки, после которого сразу же следует символ **B**, после которого сразу следует символ **r**.
```
SELECT name
  FROM passenger
 WHERE name REGEXP '^Br'
```
![image](https://github.com/user-attachments/assets/96b96fe1-1f34-491e-9da2-57872f98ef59)  

<br>

```Пример поиска в конце строки```  
Аналогичным образом интерпретируем запись ```'an$'```, отличие лишь в том, что в данном случае мы проверяем конец строки.
```
SELECT name
  FROM passenger
 WHERE name REGEXP 'an$'
```
![image](https://github.com/user-attachments/assets/f004a69f-50f4-4547-b2fb-39eb5c256405)
***
<br>

### Символьные классы

Допустим, необходимо найти строку «TU-134» или «TU-154». Это можно сделать при помощи конструкции ```[...]```, которая называется **символьным классом**, (character class), можно перечислить символы, которые могут находиться в данной позиции текста. Выражение ```[3]``` совпадает только с цифрой 3, выражение ```[5]``` совпадае только с цифрой 5, но регулярное выражение ```[35]``` совпадает с любой из этих цифр.  
![image](https://github.com/user-attachments/assets/77ff9853-14ac-4a7b-8d56-6f8698d0b2bf)  
Содержимое класса определяет список символов, с которыми совпадает данный символ регулярного выражения, поэтому здесь подразумевается связка «или».  
В контексте символьного класса метасимвол символьного класса '-' (дефис) обозначает интервал символов. Классы [0 - 9] и [a - z] обычно используются соответственно для поиска цифр и символов нижнего регистра.  
<br>

![image](https://github.com/user-attachments/assets/0e2f4c0c-1446-40ab-bb57-8f598a558307)  
Обратите внимание: дефис выполняет функции метасимвола только внутри символьного класса – в остальных случаях он совпадает с обычным дефисом. Более того, даже в символьных классах дефис не всегда интерпретируется как метасимвол. Если дефис является первым символом, указанным в классе, он заведомо не может определять интервал и поэтому интерпретируется как литерал. 
***
<br>

### Инвертированные символьные классы

Если вместо ```[...]``` используется запись ```[^...]```, класс совпадает с любыми символами, не входящими в приведенный список. Например, ```[^1-6]``` совпадает с символом, не принадлежащим интервалу от 1 до 6. Префикс ```^``` в каком-то смысле «инвертирует» список, вместо того чтобы перечислять символы, принадлежащие классу, вы перечисляете символы, не входящие в него.  
<br>

Скрипт вернет все страны, имена которых начинаются с прописной или строчной буквы А, за которой сразу следует строчная u.
```
SELECT *
  FROM public.countries
 WHERE name ~ '^[Aa]u' 
```
![image](https://github.com/user-attachments/assets/58c626a1-6bf2-458a-91f5-0931022e6ab5)  
<br>

Наоборот, добавив крышку на первую позицию в символьный класс мы инвертируем запрос, котороый вернет страны страны НЕ начинающиеся с прописной или строчной А, но за которой сразу следует u.
```
SELECT *
  FROM public.countries
 WHERE name ~ '^[^Aa]u'
```
![image](https://github.com/user-attachments/assets/8ec3f9e5-6fad-4b2f-9767-405f8344465f)  
За пределами символьного класса символ ```^``` выполняет привязку позиции к началу строки, внутри класса он является метасимволом класса, но лишь в том случае, если следует сразу же после открывающей скобки (в противном случае он интерпретируется как обычный символ). 
***
<br>

### Один произвольный символ
Метасимвол ```.``` (точка) представляет собой сокращенную форму записи для символьного класса, совпадающего с любым символом. Он применяется в тех случаях, когда в некоторых позициях регулярного выражения могут находиться произвольные символы.  
<br>
```
SELECT *
  FROM countries
 WHERE countries.code ~ '^[Aa].[Oo]'
```
ИЛИ (равнозначный запрос без учета регистра  
```
SELECT *
  FROM countries
 WHERE countries.code ~* '^a.o'
```
<br>
Вернет записи отвечающие условию - поле code, верни запись, в которой на первом месте загралвая или строчная буква A, сразу после нее любой символ, затем заглавная или строчная О.  
<br>

![image](https://github.com/user-attachments/assets/2552e40b-fae7-4a40-8780-1197d430e3f4)  
***
<br>

### Выбор. Один из нескольких выражений  
Очень удобный метасимвол ```|``` означает «или». Он позволяет объединить несколько регулярных выражений в одно, совпадающее с любым из выражений компонентов. Например, ```[Kabul]``` и ```[Kabol]``` – два разных выражения, a ```Kabul|Kabol``` – одно выражение, совпадающее с любой из этих строк. Подвыражения, объединенные этим способом, называются альтернативами (*alternatives*).  
Круглые скобки отделяют конструкцию выбора от остального выражения (и, кстати говоря, тоже являются метасимволами). Конструкция вида ```'^[Kabul|Kabol]'``` нам не подойдет – в символьном классе символ ```|``` является обычным символом. 
В выражении ```'^(Kabul|Kabol)'``` Конструкция выбора действует только внутри круглых скобок. Будьте внимательны и не путайте конструкцию выбора с символьными классами. Символьный класс представляет один символ целевого текста.  
<br>
![image](https://github.com/user-attachments/assets/be152c4d-d496-4b6f-a099-e358f2109092)
<br>

В конструкциях выбора каждая альтернатива может являться полноценным регулярным выражением, совпадающим с произвольным количеством символов.   
Сравните два выражения: ```^From|Subject|Date:•```  ```^(From|Subject|Date):•```. 
  Первое выражение состоит из трех простых альтернатив; оно означает «```^From```, или ```Subject```, или ```Date:•```» и потому особой пользы не приносит. Нам нужно, чтобы префикс ```^``` и суффикс ```:•``` относились к каждой из альтернатив. Для
этого конструкция выбора «ограничивается» круглыми скобками: ```^(From|Subject|Date):•```  
  Действие выбора ограничивается круглыми скобками, поэтому приведенное выражение буквально означает: «начало строки, затем одна из подстрок ```From```, ```Subject``` или ```Date``` и затем ```:•```». Оно совпадает в следую щих трех случаях:  
1. Начало строки, символы F·r·o·m, а затем ‘:•’ или  
2. Начало строки, символы S·u·b·j·e·c·t, а затем ‘:•’ или  
3. Начало строки, символы D·a·t·e, а затем ‘:•’.
<br>

Cовпадение происходит в каждой строке, которая начинается либо с ```From:•```, либо с ```Subject:•```, либо с ```Date:•```, – именно то, что нам нужно.  
![image](https://github.com/user-attachments/assets/79a93496-9e43-4fae-9fe8-18e9d1f4e711)
***
<br>

### Границы слов
Одна из распространенных проблем, возникающих при поиске, заключается в том, что регулярное выражение случайно совпадает с последовательностью символов, входящих в другое слово.  
Для примера в таблицу со странами добавим еще две: Czech и Czechoslovakia. Наша задача вернуть строки, состоящие из одного слова, при этом последовательность этого слова может являться частью другого. Для решения нам необходимо явно обозначить начало и конец искомого слова. Мы используем метасимволы начала ```\y``` и конца ```\y``` слова. Они представляют собой аналоги ```^``` и ```$``` на уровне слов и обозначают позицию, находящуюся, соответственно, в начале и в конце слова.  
  Выражение ```~* '\y(czech)\y'``` буквально означает "начало слова, за которым следует последовательность символов czech, конец слова", без учета регистра ```~*```. Это позволяет нам вернуть только отдельные слова, которые не будут являться частями других слов, как, например czech является частью слова czechoslovakia.  
<br>
```
SELECT *
FROM public.countries
WHERE name ~* '\y(czech)\y';
```
![image](https://github.com/user-attachments/assets/c970cc48-ef86-47d5-8b47-df7251fbdf6e)  
<br>

```
SELECT *
FROM public.countries
WHERE name ~* '\y(czech)';
```
![image](https://github.com/user-attachments/assets/9a8af185-4255-4ed1-84f1-7050f55eaac8)  
В этом примере помимо отдельных слов, выражение возвращает также записи, где последовательность czech является частью других слов, т.к. мы явно не указали конец слова.  
***
<br>

### Необязательные элементы
Рассмотрим пример поиска слова Emmael или Emael. Поскольку эти два слова отличаются только символом m, для их поиска можно использовать выражение ```'^Emm?ael'```. Метасимвол ```?``` (знак вопроса) означает, что предшествующий ему символ является необязательным. Он помещается сразу же вслед за символом, который может появиться в этом месте в выражении, но его отсутствие не должно влиять на успешный результат поиска.  
<br>
```
SELECT * 
  FROM public.superheroes
 WHERE name ~* '^Emm?ael'
```
<br>

![image](https://github.com/user-attachments/assets/6253818d-2b37-4722-8401-84e19b32c7cb)   
<br>
В отличие от других метасимволов, знак вопроса воздействует только на предшествующий ему элемент выражения. Таким образом, выражение ```'^Emm?ael'``` интерпретируется как «```E```, за которым следует ```m```, затем ```m?```, затем ```a```, затем ```e```, затем ```l```». В части ```m?``` выражение всегда будет иметь истинное значение: в одних случаях эта часть будет соответствовать имеющемуся символу ```m```, в других случаях – его отсутствию. 
<br>

Рассмотрим другой пример – поиск даты, представляющей 4 июля (July), где название месяца «July» может быть записано как July или Jul, а число может быть записано как fourth, 4th или просто 4. можно было бы использовать выражение ```(July|Jul)•(fourth|4th|4)```, однако мы попробуем выразить то же самое другим способом.  
* Прежде всего, часть ```(July|Jul)``` можно сократить до ```(July?)```. Как видите, эти два выражения фактически эквивалентны. Ликвидация метасимвола ```|``` позволяет убрать круглые скобки, ставшие ненужными. Строго говоря, наличие круглых скобок не повлияет на конечный результат, однако выражение ```July?``` без скобок воспринимается немного проще. В результате мы получили выражение ```July?•(fourth|4th|4)```.  
* Переходим ко второй половине выражения. ```4th|4``` можно сократить до ```4(th)?```. Как видите, ```?``` может присоединяться и к выражениям в круглых скобках. Подвыражение внутри скобок может быть сколь угодносложным, но «снаружи» оно воспринимается как единое целое. Группировка для ```?``` является одним из главных применений круглых скобок.
<br>

Итак, наше выражение принимает вид ```July?•(fourth|4(th)?```. Хотя оно содержит довольно много метасимволов и даже вложенные круглые скобки, расшифровать и понять его не так уж трудно.   
***
<br>

### Другие квантификаторы
У вопросительного знака имеются родственники – ```+``` (плюс) и ```*``` (звездочка). Метасимвол ```+``` обозначает «один или несколько экземпляров непосредственно предшествующего элемента», a ```*``` – «любое количество экземпляров элемента (в том числе и нулевое)». Три метасимвола, которые могут совпадать с переменным количеством экземпляров элемента, ```?```, ```+``` и ```*```, называются **квантификаторами**, поскольку они определяют количество элементов, на которые воздействуют.  
* ```.?``` - допускает не более одного необязательного символа.  
* ```.*``` - произвольное число необязательных символов.  
* ```.+``` - требуеn наличия хотя бы одного символа.
<br>

![image](https://github.com/user-attachments/assets/20ea681e-ee0b-4e0f-b0a6-8f1a2581f8cd)  
<br>

Рассмотрим пример. Предположим, нам необходимо вывести записи о всех супергероях, фамилии которых заканчиваются на 'ff'.  
```
SELECT *
  FROM public.superheroes
 WHERE name ~* '\s([a-z]+ff)(\s|\(|$)'
```
Верни записи:  
* ```~*``` - регулярное выражение, звездочка игнорирует регистр;  
* ```\s([a-z]+ff)```:  
  * подстрока начинается с пробела ```\s```;  
  * ```[a-z]``` - символьный класс, возвращает одну букву алфавита (указаны в нижнем регистре, т.к. у нас есть ```*```);  
  * ```+ff```  - оканчивается на ff, перед ним любое количество символьных классов но не менее одного.
* за которым следует ```(\s|\(|$)```:  
  * либо пробел ```\s```;  
  * либо скобка ```\(```;  
  * либо конец строки ```$```;  
Это гарантирует, что мы захватываем фамилию только в том случае, если она действительно является последней частью имени или перед скобками.
<br>

![image](https://github.com/user-attachments/assets/ad75d7de-c4e1-4b16-bcee-bf2abf88d265)
***
<br>

### Определение интервалов количества экземпляров (интервальный квантатор)  
Например, выражение ```{3,12}``` совпадает до 12 раз, если это возможно, но может ограничиться и 3 совпадениями.  
Для примера давайте вернем все записи, в которых имена супер-героев состоят из 4 букв.  
```
SELECT *
  FROM public.superheroes
 WHERE name ~* '^\y[a-z]{4}\y'
```
Регулярное выражение можно интерпретировать как:  
* ```~*``` - регулярное выражение без учета регистра;  
* ```^``` - ищи от начала строки;  
* ```\y...\y``` - в рамках одного слова, исключаем случаи, когда наш шаблон из 4 символов будет являться частью любых дргуих последовательностей, например из 5 и более символов;  
* ```[a-z]``` - символьный класс, любая из букв английского алфавита;  
* ```{4}``` - повторить 4 раза.  
Таким образом наш шаблон позволит вернуть слова, которые состоят из 4 любых букв английского алфавита в рамках одного слова.  
<br>

![image](https://github.com/user-attachments/assets/1d991d78-a3e3-42f3-8d62-0d19a013f74e)  
У всех в имени по 4 символа, значит наше регулярное выражение отработало верно.  
***
<br>

### Экранирование
Как включить в регулярное выражение символ, который обычно интерпретируется как метасимвол? Наприме, метасимвол ```.``` (точка) совпадает с произвольным символом. Метапоследовательность, совпадающая с литеральной точкой, состоит из обычной точки и экранирующего префикса ```\.```. Экранирование может выполняться со всеми стандартными метасимволами кроме метасимволов символьных классов. Экранированный метасимвол теряет свой особый смысл и становится обычным литералом. Например, при попытке поиска пользователя с почтой *ega.att* по регулярному выражению ```~* 'ega.att'``` в результат будут вклю чены строки типа *megawatt*.  
<br>
```
SELECT * 
  FROM public.customers
 WHERE email ~* 'ega.att'
```  
![image](https://github.com/user-attachments/assets/1f8ae6b3-1df7-401f-9324-98d4c2254f85)  
<br>

Экранируем точку, теперь вместо "любой символ" является обычным литералом.  
```
SELECT * 
  FROM public.customers
 WHERE email ~* 'ega\.att'
```  
![image](https://github.com/user-attachments/assets/34fb16d1-17cd-49e9-87ff-8bac2da9c082)   
<br>

Другой пример - поиск подстроки, заключенной в круглые скобки. Мы помним, что круглые скобки используются, например, для создания групп с последующим применением к группе квантификатора ```*```, ```+``` или ```|```. Задача - вернуть записи, в которых главного героя зовут *Peter*, имя указано в скобках.  
<br>

```
SELECT * 
  FROM public.superheroes
 WHERE name ~* '(Peter.*)'
```
Казалось бы, все просто - верни строки, в которых последовательность символов совпадает с шаблоном: круглая скобка открывается, затем имя Peter и любое количество символов, скобка закрывается. Однако круглые скобки являютя метасимволами и нам придется прибегать к экранированию.  

![image](https://github.com/user-attachments/assets/76179194-16f5-4c6f-ba18-0f0980f9820a)  
<br>

Немного подправим наш скрипт.  
```
SELECT * 
  FROM public.superheroes
 WHERE name ~* '\(Peter.*)'
```
Логика та же, Открытая скобка, последовательность букв, из которых состоит имя, дальше любое количество символов и закрывающая скобка.  
<br>
![image](https://github.com/user-attachments/assets/56dca7f9-398c-4b59-8e8d-cb2cd7baffe6)  
<br> 
Запрос вернул единственную подходящую запись.  
***
<br>

### 








